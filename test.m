%adjf = [0 5 2 0 5; 0 0 0 0 5; 0 0 0 4 0; 0 0 2 0 4; 0 0 0 2 0];%adjcf = [0 5 5 0 5; 0 0 0 0 5; 0 0 0 5 0; 0 0 0 0 5; 0 5 0 0 0];%[a,b]=AugmentShortestPath(adjf,adjcf);##adjcf = [0 3 6 0 0 0;##         0 0 0 0 5 0;##         0 0 0 8 0 0;##         0 0 0 0 9 3;##         0 0 0 0 0 2;##         0 0 0 0 0 0];##[valf, adjMf] = findMaxflow(adjcf)##adjG = [0 1 1; 1 0 0; 1 0 0];##inputNode = [2];##tellSCornot(adjG, inputNode)pkg load controlclear alladdpath('./NetworkAnalysisTool');% Prelimary information##adjG = [-0.05 -0.5 -0.3 -0.6; ##        0.1 -0.05 0 0; ##        0.1 0 -0.05 0;##        0.1 0 0 -0.05];adjG = [0 -0.5 -0.8 -0.6;         1 0 0 0;         1 0 0 0;        1 0 0 0];K = 2;                  % Cardinality constraints  ep = 0.001;              % EpsilonT = 10;                  % Integration termination timeDiv = 100;              % Integration resolution (division of the total time)% Measure the graph [x_1,y_1] = size(adjG);adjG_topo = zeros(x_1,y_1);if x_1 != y_1   error('Adj not square!');endif isConnected(abs(adjG)) == 0    error(' The graph entered is not connected.');end% Give the topological information for the graph.for i = 1 : x_1  for j = 1 : y_1    if adjG(i,j) != 0      adjG_topo(i,j) = 1;    end  endend% Determine whether the cardinality constraint is adequate.CardEnoicon = isCardEnough(adjG_topo,K,x_1);if CardEnoicon == 0  error(' The allowed cardinality is too small! ');endinputNode = [];potSelection = [];auxGSTadj = zeros(3 * x_1 + 2,3 * x_1 + 2);auxGSTadj(2 : (x_1 + 1) , (2 * x_1+2):(3 * x_1 + 1)) = adjG_topo;auxGSTadj(1 , 2 : (2 * x_1 + 1) ) = ones(1,2 * x_1);auxGSTadj((2 * x_1 + 2) : (3 * x_1 + 1) , 3 * x_1 + 2) = ones(x_1,1);for i = 1 : K  for j = 1 : y_1    if ismember(j,inputNode) != 1      inputNode_copy = inputNode;      inputNode_copy = [inputNode_copy j];      auxGSTadj_copy = auxGSTadj;      auxGSTadj_copy(x_1 + j + 1, 2 * x_1 + j + 1) = 1;     else      continue    end    [valf,adjMf] = findMaxflow(auxGSTadj_copy);    if valf < (x_1 - K + i)       continue    else    potSelection = [potSelection j];    end  end    multiObj = [];  for k = 1 : length(potSelection)    valobj = obj2(T,Div,adjG,[inputNode potSelection(k)],ep);    multiObj = [multiObj valobj];  end  [maxobj,newSelectionind] = min(multiObj);  newSelection = potSelection(newSelectionind);  inputNode = [inputNode newSelection];  auxGSTadj(x_1 + newSelection + 1 , 2 * x_1 + newSelection + 1) = 1;  potSelection = [];
endinputNode
